from __future__ import annotations
import json

import logging
import multiprocessing as mp
import os
import pathlib
import signal
import subprocess
import time
import tempfile
import traceback
from contextlib import contextmanager
from inspect import signature
from typing import Any, Awaitable, Callable, TextIO

import pandas as pd
import toml
from pydantic import BaseModel
from tqdm import tqdm

import argparse

# Use OpenHands SDK logger
from openhands.sdk.logger import get_logger
logger = get_logger("swe_bench_eval")


# Evaluation parser used by swe_bench/run_infer.py
# Minimal, stable surface that mirrors the arguments run_infer expects
def get_evaluation_parser():
    parser = argparse.ArgumentParser(add_help=True)
    parser.add_argument('--agent-cls', dest='agent_cls', type=str, default=os.environ.get('AGENT_CLS', 'CodeActAgent'))
    parser.add_argument('--max-iterations', dest='max_iterations', type=int, default=int(os.environ.get('MAX_ITERATIONS', '50')))
    parser.add_argument('--eval-output-dir', dest='eval_output_dir', type=str, default=os.environ.get('EVAL_OUTPUT_DIR', './eval_out'))
    parser.add_argument('--eval-num-workers', dest='eval_num_workers', type=int, default=int(os.environ.get('EVAL_NUM_WORKERS', '1')))
    parser.add_argument('--eval-n-limit', dest='eval_n_limit', type=int, default=int(os.environ.get('EVAL_N_LIMIT', '0')))
    parser.add_argument('--eval-note', dest='eval_note', type=str, default=os.environ.get('EVAL_NOTE', ''))
    parser.add_argument('--model', dest='model', type=str, default=os.environ.get('MODEL', 'claude-3-5-sonnet-latest'))
    # Additional legacy flags used elsewhere in run_infer
    parser.add_argument('--num-workers', dest='num_workers', type=int, default=int(os.environ.get('NUM_WORKERS', '1')))
    parser.add_argument('--continue-on-error', dest='continue_on_error', action='store_true')
    parser.add_argument('--results-dir', dest='results_dir', type=str, default=os.environ.get('RESULTS_DIR', './results'))
    parser.add_argument('--n-limit', dest='n_limit', type=int, default=int(os.environ.get('N_LIMIT', '0')))
    parser.add_argument('--resume', dest='resume', action='store_true')
    parser.add_argument('--shuffle', dest='shuffle', action='store_true')
    return parser


def get_console_handler(log_level=logging.INFO) -> logging.Handler:
    h = logging.StreamHandler()
    h.setLevel(log_level)
    return h

# Compatibility classes and runtime for local mode (new SDK)
class MessageAction:
    def __init__(self, content: str, image_urls: list[str] | None = None):
        self.content = content
        self.image_urls = image_urls or []


class CmdRunAction:
    def __init__(self, command: str):
        self.command = command
        self._hard_timeout: int | None = None

    def set_hard_timeout(self, seconds: int):
        self._hard_timeout = seconds


class FileReadAction:
    def __init__(self, path: str):
        self.path = path


class CmdOutputObservation:
    def __init__(self, content: str, exit_code: int = 0):
        self.content = content
        self.exit_code = exit_code

    def __str__(self):
        return f"CmdOutputObservation(exit_code={self.exit_code}, content={self.content[:120]!r}...)"


class ErrorObservation:
    def __init__(self, content: str, exit_code: int | None = None):
        self.content = content
        self.exit_code = exit_code if exit_code is not None else 1

    def __str__(self):
        return f"ErrorObservation(exit_code={self.exit_code}, content={self.content[:120]!r}...)"


class FileReadObservation:
    def __init__(self, content: str):
        self.content = content

    def __str__(self):
        return f"FileReadObservation(len={len(self.content)})"


class SandboxConfig:
    def __init__(self, **kwargs):
        # store arbitrary fields used by run_infer
        for k, v in kwargs.items():
            setattr(self, k, v)
        # defaults expected later
        self.base_container_image: str | None = getattr(self, 'base_container_image', None)
        self.enable_auto_lint: bool = getattr(self, 'enable_auto_lint', False)
        self.use_host_network: bool = getattr(self, 'use_host_network', False)
        self.platform: str | None = getattr(self, 'platform', None)
        self.remote_runtime_resource_factor: int = getattr(self, 'remote_runtime_resource_factor', 1)


class AgentConfig:
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)


class OpenHandsConfig:
    def __init__(self, *, default_agent: str, run_as_openhands: bool, max_iterations: int, enable_browser: bool, runtime: str, sandbox: SandboxConfig, workspace_base=None, workspace_mount_path=None):
        self.default_agent = default_agent
        self.run_as_openhands = run_as_openhands
        self.max_iterations = max_iterations
        self.enable_browser = enable_browser
        self.runtime = runtime
        self.sandbox = sandbox
        self.workspace_base = workspace_base
        self.workspace_mount_path = workspace_mount_path
        self.llm_config: LLMConfig | None = None
        self.agent_config: AgentConfig | None = None

    def set_llm_config(self, llm_config: LLMConfig | None, name: str | None = None):
        if llm_config is not None:
            self.llm_config = llm_config

    def set_agent_config(self, agent_config: AgentConfig):
        self.agent_config = agent_config


class SimpleMetrics:
    def __init__(self):
        self._data: dict[str, Any] = {}

    def get(self) -> dict[str, Any]:
        return dict(self._data)


class ConversationState:
    def __init__(self, history: list[Any] | None = None, last_error: str | None = None):
        self.history = history or []
        self.last_error = last_error
        self.metrics = SimpleMetrics()


def get_llm_config_arg(name: str) -> LLMConfig | None:
    # no-op stub for draft_editor
    return None


def sleep_if_should_continue(seconds: int):
    time.sleep(seconds)


def call_async_from_sync(func):
    # Our connect is sync; if a coroutine function is passed, run it.
    try:
        result = func()
        return result
    except TypeError:
        # If passed a coroutine object or function, try running it in a new loop
        import asyncio as _asyncio
        return _asyncio.run(func())


class LocalRuntime:
    def __init__(self, workspace_root: str | None = None):
        self.root = workspace_root or tempfile.mkdtemp(prefix="local_runtime_")
        self.workspace_root = os.path.join(self.root, "workspace")
        self.swe_util_root = os.path.join(self.root, "swe_util")
        os.makedirs(self.workspace_root, exist_ok=True)
        os.makedirs(self.swe_util_root, exist_ok=True)
        self.cwd = self.root

    def map_path(self, path: str) -> str:
        if path.startswith('/workspace'):
            return path.replace('/workspace', self.workspace_root, 1)
        if path.startswith('/swe_util'):
            return path.replace('/swe_util', self.swe_util_root, 1)
        if path.startswith('~'):
            return os.path.join(self.root, path[2:] if path.startswith('~/') else path[1:])
        return path

    def rewrite_command(self, cmd: str) -> str:
        cmd = cmd.replace('/workspace', self.workspace_root)
        cmd = cmd.replace('/swe_util', self.swe_util_root)
        return cmd

    def connect(self):
        return None

    def close(self):
        return None

    def copy_to(self, src: str, dest: str):
        dest_path = self.map_path(dest)
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        import shutil
        shutil.copy2(src, dest_path)

    def run_action(self, action: Any) -> Any:
        if isinstance(action, FileReadAction):
            try:
                p = action.path
                if not os.path.isabs(p):
                    p = os.path.join(self.cwd, p)
                with open(p, 'r') as f:
                    return FileReadObservation(content=f.read())
            except Exception as e:
                return ErrorObservation(content=str(e))
        if isinstance(action, CmdRunAction):
            cmd = action.command.strip()
            # handle cd specially to maintain cwd across commands
            if cmd.startswith('cd '):
                path = cmd[3:].strip()
                path = self.map_path(path)
                os.makedirs(path, exist_ok=True)
                self.cwd = path
                return CmdOutputObservation(content='', exit_code=0)
            # no-op commands
            if cmd in ('C-c', 'C-z'):
                return CmdOutputObservation(content='', exit_code=0)
            if cmd.startswith('source '):
                # ignore sourcing; assume env already fine
                return CmdOutputObservation(content='', exit_code=0)
            if cmd == 'which python':
                # pretend testbed python
                return CmdOutputObservation(content='/usr/bin/testbed/python', exit_code=0)
            # rewrite mount paths
            cmd = self.rewrite_command(cmd)
            try:
                import subprocess as _sp
                completed = _sp.run(
                    ['bash', '-lc', cmd],
                    cwd=self.cwd,
                    env={**os.environ, 'HOME': self.root},
                    stdout=_sp.PIPE,
                    stderr=_sp.STDOUT,
                    text=True,
                    timeout=getattr(action, '_hard_timeout', None),
                )
                return CmdOutputObservation(content=completed.stdout or '', exit_code=completed.returncode)
            except Exception as e:
                return ErrorObservation(content=str(e))
        return ErrorObservation(content=f'Unsupported action type: {type(action).__name__}')


def create_runtime(config: OpenHandsConfig) -> LocalRuntime:
    return LocalRuntime()


def run_controller(*, config: OpenHandsConfig, initial_user_action: MessageAction, runtime: LocalRuntime, fake_user_response_fn=None) -> ConversationState:
    try:
        from openhands.sdk import LLM, Agent, Conversation, LLMConvertibleEvent, Message, TextContent
        from openhands.tools import BashTool, FileEditorTool
    except Exception as e:
        logger.error(f"Failed to import OpenHands SDK: {e}")
        return ConversationState(history=[], last_error=str(e))

    llm_cfg = config.llm_config or LLMConfig()
    llm = LLM(config=llm_cfg)

    workspace_dir_name = None
    # best-effort parse workspace from action content; not strictly needed
    tools = [
        BashTool(working_dir=runtime.workspace_root),
        FileEditorTool(),
    ]
    agent = Agent(llm=llm, tools=tools)

    history: list[Any] = []

    def _cb(event):
        try:
            # store only convertible events to keep size small
            if hasattr(event, 'to_llm_message'):
                history.append(event)
        except Exception:
            pass

    conv = Conversation(agent=agent, callbacks=[_cb])
    conv.send_message(Message(role='user', content=[TextContent(text=initial_user_action.content)]))
    try:
        conv.run()
        return ConversationState(history=history, last_error=None)
    except Exception as e:
        logger.exception("Conversation run failed")
        return ConversationState(history=history, last_error=str(e))


def event_to_dict(event: Any) -> dict[str, Any]:
    # Convert SDK event into a serializable dict
    try:
        if hasattr(event, 'to_llm_message'):
            msg = event.to_llm_message()
            contents = []
            for c in getattr(msg, 'content', []) or []:
                if hasattr(c, 'text'):
                    contents.append({'type': 'text', 'text': c.text})
                else:
                    contents.append(str(c))
            return {'role': getattr(msg, 'role', 'assistant'), 'content': contents}
    except Exception:
        pass
    # fallback
    return {'event': str(event)}

# Compatibility classes and runtime for local mode (new SDK)
class MessageAction:
    def __init__(self, content: str, image_urls: list[str] | None = None):
        self.content = content
        self.image_urls = image_urls or []


class CmdRunAction:
    def __init__(self, command: str):
        self.command = command
        self._hard_timeout: int | None = None

    def set_hard_timeout(self, seconds: int):
        self._hard_timeout = seconds


class FileReadAction:
    def __init__(self, path: str):
        self.path = path


class CmdOutputObservation:
    def __init__(self, content: str, exit_code: int = 0):
        self.content = content
        self.exit_code = exit_code

    def __str__(self):
        return f"CmdOutputObservation(exit_code={self.exit_code}, content={self.content[:120]!r}...)"


class ErrorObservation:
    def __init__(self, content: str, exit_code: int | None = None):
        self.content = content
        self.exit_code = exit_code if exit_code is not None else 1

    def __str__(self):
        return f"ErrorObservation(exit_code={self.exit_code}, content={self.content[:120]!r}...)"


class FileReadObservation:
    def __init__(self, content: str):
        self.content = content

    def __str__(self):
        return f"FileReadObservation(len={len(self.content)})"


class SandboxConfig:
    def __init__(self, **kwargs):
        # store arbitrary fields used by run_infer
        for k, v in kwargs.items():
            setattr(self, k, v)
        # defaults expected later
        self.base_container_image: str | None = getattr(self, 'base_container_image', None)
        self.enable_auto_lint: bool = getattr(self, 'enable_auto_lint', False)
        self.use_host_network: bool = getattr(self, 'use_host_network', False)
        self.platform: str | None = getattr(self, 'platform', None)
        self.remote_runtime_resource_factor: int = getattr(self, 'remote_runtime_resource_factor', 1)


class AgentConfig:
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)


class OpenHandsConfig:
    def __init__(self, *, default_agent: str, run_as_openhands: bool, max_iterations: int, enable_browser: bool, runtime: str, sandbox: SandboxConfig, workspace_base=None, workspace_mount_path=None):
        self.default_agent = default_agent
        self.run_as_openhands = run_as_openhands
        self.max_iterations = max_iterations
        self.enable_browser = enable_browser
        self.runtime = runtime
        self.sandbox = sandbox
        self.workspace_base = workspace_base
        self.workspace_mount_path = workspace_mount_path
        self.llm_config: LLMConfig | None = None
        self.agent_config: AgentConfig | None = None

    def set_llm_config(self, llm_config: LLMConfig | None, name: str | None = None):
        if llm_config is not None:
            self.llm_config = llm_config

    def set_agent_config(self, agent_config: AgentConfig):
        self.agent_config = agent_config


class SimpleMetrics:
    def __init__(self):
        self._data: dict[str, Any] = {}

    def get(self) -> dict[str, Any]:
        return dict(self._data)


class ConversationState:
    def __init__(self, history: list[Any] | None = None, last_error: str | None = None):
        self.history = history or []
        self.last_error = last_error
        self.metrics = SimpleMetrics()


def get_llm_config_arg(name: str) -> LLMConfig | None:
    # no-op stub for draft_editor
    return None


def sleep_if_should_continue(seconds: int):
    time.sleep(seconds)


def call_async_from_sync(func):
    # Our connect is sync; if a coroutine function is passed, run it.
    try:
        result = func()
        return result
    except TypeError:
        # If passed a coroutine object or function, try running it in a new loop
        import asyncio as _asyncio
        return _asyncio.run(func())


class LocalRuntime:
    def __init__(self, workspace_root: str | None = None):
        self.root = workspace_root or tempfile.mkdtemp(prefix="local_runtime_")
        self.workspace_root = os.path.join(self.root, "workspace")
        self.swe_util_root = os.path.join(self.root, "swe_util")
        os.makedirs(self.workspace_root, exist_ok=True)
        os.makedirs(self.swe_util_root, exist_ok=True)
        self.cwd = self.root

    def map_path(self, path: str) -> str:
        if path.startswith('/workspace'):
            return path.replace('/workspace', self.workspace_root, 1)
        if path.startswith('/swe_util'):
            return path.replace('/swe_util', self.swe_util_root, 1)
        if path.startswith('~'):
            return os.path.join(self.root, path[2:] if path.startswith('~/') else path[1:])
        return path

    def rewrite_command(self, cmd: str) -> str:
        cmd = cmd.replace('/workspace', self.workspace_root)
        cmd = cmd.replace('/swe_util', self.swe_util_root)
        return cmd

    def connect(self):
        return None

    def close(self):
        return None

    def copy_to(self, src: str, dest: str):
        dest_path = self.map_path(dest)
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        import shutil
        shutil.copy2(src, dest_path)

    def run_action(self, action: Any) -> Any:
        if isinstance(action, FileReadAction):
            try:
                p = action.path
                if not os.path.isabs(p):
                    p = os.path.join(self.cwd, p)
                with open(p, 'r') as f:
                    return FileReadObservation(content=f.read())
            except Exception as e:
                return ErrorObservation(content=str(e))
        if isinstance(action, CmdRunAction):
            cmd = action.command.strip()
            # handle cd specially to maintain cwd across commands
            if cmd.startswith('cd '):
                path = cmd[3:].strip()
                path = self.map_path(path)
                os.makedirs(path, exist_ok=True)
                self.cwd = path
                return CmdOutputObservation(content='', exit_code=0)
            # no-op commands
            if cmd in ('C-c', 'C-z'):
                return CmdOutputObservation(content='', exit_code=0)
            if cmd.startswith('source '):
                # ignore sourcing; assume env already fine
                return CmdOutputObservation(content='', exit_code=0)
            if cmd == 'which python':
                # pretend testbed python
                return CmdOutputObservation(content='/usr/bin/testbed/python', exit_code=0)
            # rewrite mount paths
            cmd = self.rewrite_command(cmd)
            try:
                import subprocess as _sp
                completed = _sp.run(
                    ['bash', '-lc', cmd],
                    cwd=self.cwd,
                    env={**os.environ, 'HOME': self.root},
                    stdout=_sp.PIPE,
                    stderr=_sp.STDOUT,
                    text=True,
                    timeout=getattr(action, '_hard_timeout', None),
                )
                return CmdOutputObservation(content=completed.stdout or '', exit_code=completed.returncode)
            except Exception as e:
                return ErrorObservation(content=str(e))
        return ErrorObservation(content=f'Unsupported action type: {type(action).__name__}')


def create_runtime(config: OpenHandsConfig) -> LocalRuntime:
    return LocalRuntime()


def run_controller(*, config: OpenHandsConfig, initial_user_action: MessageAction, runtime: LocalRuntime, fake_user_response_fn=None) -> ConversationState:
    try:
        from openhands.sdk import LLM, Agent, Conversation, LLMConvertibleEvent, Message, TextContent
        from openhands.tools import BashTool, FileEditorTool
    except Exception as e:
        logger.error(f"Failed to import OpenHands SDK: {e}")
        return ConversationState(history=[], last_error=str(e))

    llm_cfg = config.llm_config or LLMConfig()
    llm = LLM(config=llm_cfg)

    workspace_dir_name = None
    # best-effort parse workspace from action content; not strictly needed
    tools = [
        BashTool(working_dir=runtime.workspace_root),
        FileEditorTool(),
    ]
    agent = Agent(llm=llm, tools=tools)

    history: list[Any] = []

    def _cb(event):
        try:
            # store only convertible events to keep size small
            if hasattr(event, 'to_llm_message'):
                history.append(event)
        except Exception:
            pass

    conv = Conversation(agent=agent, callbacks=[_cb])
    conv.send_message(Message(role='user', content=[TextContent(text=initial_user_action.content)]))
    try:
        conv.run()
        return ConversationState(history=history, last_error=None)
    except Exception as e:
        logger.exception("Conversation run failed")
        return ConversationState(history=history, last_error=str(e))


def event_to_dict(event: Any) -> dict[str, Any]:
    # Convert SDK event into a serializable dict
    try:
        if hasattr(event, 'to_llm_message'):
            msg = event.to_llm_message()
            contents = []
            for c in getattr(msg, 'content', []) or []:
                if hasattr(c, 'text'):
                    contents.append({'type': 'text', 'text': c.text})
                else:
                    contents.append(str(c))
            return {'role': getattr(msg, 'role', 'assistant'), 'content': contents}
    except Exception:
        pass
    # fallback
    return {'event': str(event)}

# SDK does not expose LLMConfig; alias LLM as LLMConfig for compatibility
from openhands.sdk.llm import LLM as LLMConfig
from openhands.sdk.conversation.state import ConversationState
#Commented for migration
#from openhands.core.config import SandboxConfig
#Commented for migration
#from openhands.core.config.agent_config import AgentConfig
#Commented for migration
#from openhands.core.config.condenser_config import (
#    CondenserConfig,
#    NoOpCondenserConfig,
#)
##Commented for migration
#from openhands.core.exceptions import (
#    AgentRuntimeBuildError,
#    AgentRuntimeDisconnectedError,
#    AgentRuntimeError,
#    AgentRuntimeNotFoundError,
#    AgentRuntimeNotReadyError,
#    AgentRuntimeTimeoutError,
#    AgentRuntimeUnavailableError,
#)
#Commented for migration
#from openhands.core.logger import get_console_handler
#Commented for migration
#from openhands.core.logger import openhands_logger as logger
#Commented for migration
#from openhands.events.action import Action
#Commented for migration
#from openhands.events.action.message import MessageAction
#Commented for migration
#from openhands.events.event import Event
#Commented for migration
#from openhands.events.serialization.event import event_to_dict
#Commented for migration
#from openhands.events.utils import get_pairs_from_events
#Commented for migration
#from openhands.memory.condenser import get_condensation_metadata


class EvalMetadata(BaseModel):
    agent_class: str
    llm_config: LLMConfig
    #Commented for migration
    #agent_config: AgentConfig | None = None
    max_iterations: int
    eval_output_dir: str
    start_time: str
    git_commit: str
    dataset: str | None = None
    data_split: str | None = None
    details: dict[str, Any] | None = None
    #Commented for migration
    #condenser_config: CondenserConfig | None = None


class EvalOutput(BaseModel):
    # NOTE: User-specified
    instance_id: str
    # output of the evaluation
    # store anything that is needed for the score calculation
    test_result: dict[str, Any]

    instruction: str | None = None

    # Interaction info
    metadata: EvalMetadata | None = None
    # list[tuple[dict[str, Any], dict[str, Any]]] - for compatibility with the old format
    events: (
        list[dict[str, Any]] | list[tuple[dict[str, Any], dict[str, Any]]] | None
    ) = None
    metrics: dict[str, Any] | None = None
    error: str | None = None

    # Optionally save the input test instance
    instance: dict[str, Any] | None = None


class EvalException(Exception):
    pass


class EvalTimeoutException(Exception):
    pass


@contextmanager
def timeout(seconds: int):
    def timeout_handler(signum, frame):
        raise EvalTimeoutException(f'Function timed out after {seconds} seconds')

    # Set up the signal handler
    original_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(seconds)

    try:
        yield
    finally:
        # Restore the original handler and disable the alarm
        signal.alarm(0)
        signal.signal(signal.SIGALRM, original_handler)


def codeact_user_response(
    state: ConversationState,
    encapsulate_solution: bool = False,
    try_parse: Callable[[Action], str] | None = None,
) -> str:
    encaps_str = (
        (
            'Please encapsulate your final answer (answer ONLY) within <solution> and </solution>.\n'
            'For example: The answer to the question is <solution> 42 </solution>.\n'
        )
        if encapsulate_solution
        else ''
    )
    msg = (
        'Please continue working on the task on whatever approach you think is suitable.\n'
        'If you think you have solved the task, please first send your answer to user through message and then finish the interaction.\n'
        f'{encaps_str}'
        'IMPORTANT: YOU SHOULD NEVER ASK FOR HUMAN HELP.\n'
    )

    if state.events:
        # check if the last action has an answer, if so, early exit
        if try_parse is not None:
            last_action = next(
                (
                    event
                    for event in reversed(state.events)
                    if isinstance(event, Action)
                ),
                None,
            )
            ans = try_parse(last_action)
            if ans is not None:
                return '/exit'

        # check if the agent has tried to talk to the user 3 times, if so, let the agent know it can give up
        user_msgs = [
            event
            for event in state.events
            if isinstance(event, MessageAction) and event.source == 'user'
        ]
        if len(user_msgs) >= 2:
            # let the agent know that it can give up when it has tried 3 times
            return (
                msg
                + 'If you want to give up, use the "finish" tool to finish the interaction.\n'
            )
    return msg


def cleanup():
    print('Cleaning up child processes...')
    for process in mp.active_children():
        print(f'Terminating child process: {process.name}')
        process.terminate()
        process.join()


def make_metadata(
    llm_config: LLMConfig,
    dataset_name: str,
    agent_class: str,
    max_iterations: int,
    eval_note: str | None,
    eval_output_dir: str,
    data_split: str | None = None,
    details: dict[str, Any] | None = None,
    #Commented for migration
    #agent_config: AgentConfig | None = None,
    #Commented for migration
    #condenser_config: CondenserConfig | None = None,
) -> EvalMetadata:
    model_name = llm_config.model.split('/')[-1]
    model_path = model_name.replace(':', '_').replace('@', '-')
    eval_note = f'_N_{eval_note}' if eval_note else ''

    eval_output_path = os.path.join(
        eval_output_dir,
        dataset_name,
        agent_class,
        f'{model_path}_maxiter_{max_iterations}{eval_note}',
    )

    pathlib.Path(eval_output_path).mkdir(parents=True, exist_ok=True)
    pathlib.Path(os.path.join(eval_output_path, 'logs')).mkdir(
        parents=True, exist_ok=True
    )
    logger.info(f'Using evaluation output directory: {eval_output_path}')

    metadata = EvalMetadata(
        agent_class=agent_class,
        llm_config=llm_config,
        max_iterations=max_iterations,
        eval_output_dir=eval_output_path,
        start_time=time.strftime('%Y-%m-%d %H:%M:%S'),
        git_commit=subprocess.check_output(['git', 'rev-parse', 'HEAD'])
        .decode('utf-8')
        .strip(),
        dataset=dataset_name,
        data_split=data_split,
        details=details,
    )
    metadata_json = metadata.model_dump_json()
    logger.info(f'Metadata: {metadata_json}')
    with open(os.path.join(eval_output_path, 'metadata.json'), 'w') as f:
        f.write(metadata_json)

    return metadata


def prepare_dataset(
    dataset: pd.DataFrame,
    output_file: str,
    eval_n_limit: int,
    eval_ids: list[str] | None = None,
    skip_num: int | None = None,
):
    assert 'instance_id' in dataset.columns, (
        "Expected 'instance_id' column in the dataset. You should define your own unique identifier for each instance and use it as the 'instance_id' column."
    )
    id_column = 'instance_id'
    logger.info(f'Writing evaluation output to {output_file}')
    finished_ids: set[str] = set()
    if os.path.exists(output_file):
        with open(output_file, 'r') as f:
            for line in f:
                data = json.loads(line)
                finished_ids.add(str(data[id_column]))
        logger.warning(
            f'\nOutput file {output_file} already exists. Loaded {len(finished_ids)} finished instances.'
        )

    if eval_ids:
        eval_ids_converted = [dataset[id_column].dtype.type(id) for id in eval_ids]
        dataset = dataset[dataset[id_column].isin(eval_ids_converted)]
        logger.info(f'Limiting evaluation to {len(eval_ids)} specific instances.')
    elif skip_num and skip_num >= 0:
        skip_num = min(skip_num, len(dataset))
        dataset = dataset.iloc[skip_num:]
        logger.info(
            f'Starting evaluation with skipping first {skip_num} instances ({len(dataset)} instances to run).'
        )
        if eval_n_limit and eval_n_limit > 0:
            # Use fixed random seed 42 for sampling without replacement
            dataset = dataset.sample(
                min(eval_n_limit, len(dataset)), random_state=42, replace=False
            )
            logger.info(
                f'Randomly sampling {eval_n_limit} unique instances with random seed 42.'
            )
    elif eval_n_limit and eval_n_limit > 0:
        # Use fixed random seed 42 for sampling without replacement
        dataset = dataset.sample(
            min(eval_n_limit, len(dataset)), random_state=42, replace=False
        )
        logger.info(
            f'Randomly sampling {eval_n_limit} unique instances with random seed 42.'
        )

    new_dataset = [
        instance
        for _, instance in dataset.iterrows()
        if str(instance[id_column]) not in finished_ids
    ]
    logger.info(
        f'Finished instances: {len(finished_ids)}, Remaining instances: {len(new_dataset)}'
    )

    return pd.DataFrame(new_dataset)


def update_progress(
    result: EvalOutput,
    pbar: tqdm,
    output_fp: TextIO,
):
    """Update the progress bar and write the result to the output file."""
    pbar.update(1)
    pbar.set_description(f'Instance {result.instance_id}')
    pbar.set_postfix_str(f'Test Result: {str(result.test_result)[:300]}...')
    logger.info(
        f'Finished evaluation for instance {result.instance_id}: {str(result.test_result)[:300]}...\n'
    )
    output_fp.write(result.model_dump_json() + '\n')
    output_fp.flush()


def assert_and_raise(condition: bool, msg: str):
    """Raise an EvalException if the condition is not met.

    This will be used in conjunction with _process_instance_wrapper to handle retries. An EvalException should trigger a retry.
    """
    if not condition:
        raise EvalException(msg)


def log_skipped_build_maximum_retries_exceeded(
    instance, metadata, error, max_retries=1
):
    """Log and skip the instance when maximum retries are exceeded.

    Args:
        instance: The instance that failed
        metadata: The evaluation metadata
        error: The error that occurred
        max_retries: The maximum number of retries that were attempted

    Returns:
        EvalOutput with the error information
    """
    #Commented for migration
#from openhands.core.logger import openhands_logger as logger

    # Log the error
    logger.exception(error)
    logger.error(
        f'Maximum error retries reached for instance {instance.instance_id}. Could not build instance image. '
        f'Check build_error_maximum_retries_exceeded.jsonl, fix the image and run evaluation again. '
        f'Skipping this instance and continuing with others.'
    )

    # Add the instance name to build_error_maximum_retries_exceeded.jsonl in the same folder as output.jsonl
    if metadata and metadata.eval_output_dir:
        retries_file_path = os.path.join(
            metadata.eval_output_dir,
            'build_error_maximum_retries_exceeded.jsonl',
        )
        try:
            # Write the instance info as a JSON line
            with open(retries_file_path, 'a') as f:
                import json

                # No need to get Docker image as we're not including it in the error entry

                error_entry = {
                    'instance_id': instance.instance_id,
                    'error': str(error),
                    'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                }
                f.write(json.dumps(error_entry) + '\n')
            logger.info(f'Added instance {instance.instance_id} to {retries_file_path}')
        except Exception as write_error:
            logger.error(
                f'Failed to write to build_error_maximum_retries_exceeded.jsonl: {write_error}'
            )

    return EvalOutput(
        instance_id=instance.instance_id,
        test_result={},
        error=f'Maximum retries ({max_retries}) reached: {str(error)}',
        status='error',
    )


def check_maximum_retries_exceeded(eval_output_dir):
    """Check if build_error_maximum_retries_exceeded.jsonl exists and output a message."""
    #Commented for migration
#from openhands.core.logger import openhands_logger as logger

    retries_file_path = os.path.join(
        eval_output_dir, 'build_error_maximum_retries_exceeded.jsonl'
    )
    if os.path.exists(retries_file_path):
        logger.info(
            'ATTENTION: Some instances reached maximum error retries and were skipped.'
        )
        logger.info(f'These instances are listed in: {retries_file_path}')
        logger.info(
            'Fix these instances and run evaluation again with EVAL_SKIP_BUILD_ERRORS=false'
        )


def _process_instance_wrapper(
    process_instance_func: Callable[[pd.Series, EvalMetadata, bool], EvalOutput],
    instance: pd.Series,
    metadata: EvalMetadata,
    use_mp: bool,
    max_retries: int = 5,
    timeout_seconds: int | None = None,
) -> EvalOutput:
    """Wrap the process_instance_func to handle retries and errors."""
    runtime_failure_count = 0
    for attempt in range(max_retries + 1):
        try:
            kwargs = {}
            # check if process_instance_func accepts timeout_seconds parameter
            sig = signature(process_instance_func)
            if 'runtime_failure_count' in sig.parameters:
                kwargs['runtime_failure_count'] = runtime_failure_count

            if timeout_seconds is not None:
                with timeout(timeout_seconds):
                    result = process_instance_func(instance, metadata, use_mp, **kwargs)
            else:
                result = process_instance_func(instance, metadata, use_mp, **kwargs)
            return result
        except EvalTimeoutException as e:
            error = f'Timeout after {timeout_seconds} seconds'
            stacktrace = traceback.format_exc()
            msg = (
                '-' * 10
                + '\n'
                + f'Timeout ({timeout_seconds} seconds) in instance [{instance.instance_id}], Stopped evaluation for this instance.'
                + '\n'
                + '-' * 10
            )
            logger.exception(e)
            return EvalOutput(
                instance_id=instance.instance_id,
                test_result={},
                error=error,
            )
        except Exception as e:
            error = str(e)
            stacktrace = traceback.format_exc()
            if attempt == max_retries:
                msg = (
                    '-' * 10
                    + '\n'
                    + f'Error in instance [{instance.instance_id}]: {error}. Stacktrace:\n{stacktrace}'
                    + '\n'
                    + f'[Encountered after {max_retries} retries. Please check the logs and report the issue.]'
                    + '-' * 10
                )

                # Check if EVAL_SKIP_BUILD_ERRORS is set to true
                skip_errors = (
                    os.environ.get('EVAL_SKIP_BUILD_ERRORS', 'false').lower() == 'true'
                )

                if skip_errors:
                    # Use the dedicated function to log and skip maximum retries exceeded
                    return log_skipped_build_maximum_retries_exceeded(
                        instance, metadata, e, max_retries
                    )
                else:
                    # Raise an error after all retries & stop the evaluation
                    logger.exception(e)
                    raise RuntimeError(
                        f'Maximum error retries reached for instance {instance.instance_id}'
                    ) from e
            msg = (
                '-' * 10
                + '\n'
                + f'Error in instance [{instance.instance_id}]: {error}. Stacktrace:\n{stacktrace}'
                + '\n'
                + '-' * 10
                + f'[The above error occurred. Retrying... (attempt {attempt + 1} of {max_retries})]'
                + '-' * 10
                + '\n'
            )
            # e is likely an EvalException, so we can't directly infer it from type
            # but rather check if it's a fatal error
            # But it can also be AgentRuntime**Error (e.g., swe_bench/eval_infer.py)
            _error_str = type(e).__name__ + ': ' + str(e)
            if is_fatal_runtime_error(_error_str):
                runtime_failure_count += 1
                msg += f'Runtime disconnected error detected for instance {instance.instance_id}, runtime failure count: {runtime_failure_count}'
                msg += '\n' + '-' * 10 + '\n'
            logger.error(msg)
            time.sleep(5)


def _process_instance_wrapper_mp(args):
    """Wrapper for multiprocessing, especially for imap_unordered."""
    return _process_instance_wrapper(*args)


def run_evaluation(
    dataset: pd.DataFrame,
    metadata: EvalMetadata | None,
    output_file: str,
    num_workers: int,
    process_instance_func: Callable[
        [pd.Series, EvalMetadata, bool], Awaitable[EvalOutput]
    ],
    max_retries: int = 5,  # number of retries for each instance
    timeout_seconds: int | None = None,
):
    use_multiprocessing = num_workers > 1

    if metadata is not None:
        logger.info(
            f'Evaluation started with Agent {metadata.agent_class}:\n'
            f'model {metadata.llm_config.model}, max iterations {metadata.max_iterations}.\n'
        )
    else:
        logger.warning('Running evaluation without metadata.')
        logger.info(f'Evaluation started with {num_workers} workers.')

    total_instances = len(dataset)
    pbar = tqdm(total=total_instances, desc='Instances processed')
    output_fp = open(output_file, 'a')

    try:
        if use_multiprocessing:
            with mp.Pool(num_workers) as pool:
                args_iter = (
                    (
                        process_instance_func,
                        instance,
                        metadata,
                        True,
                        max_retries,
                        timeout_seconds,
                    )
                    for _, instance in dataset.iterrows()
                )
                results = pool.imap_unordered(_process_instance_wrapper_mp, args_iter)
                for result in results:
                    update_progress(result, pbar, output_fp)
        else:
            for _, instance in dataset.iterrows():
                result = _process_instance_wrapper(
                    process_instance_func=process_instance_func,
                    instance=instance,
                    metadata=metadata,
                    use_mp=False,
                    max_retries=max_retries,
                )
                update_progress(result, pbar, output_fp)

    except KeyboardInterrupt:
        print('\nKeyboardInterrupt received. Cleaning up...\n')
        cleanup()

    output_fp.close()
    logger.info('\nEvaluation finished.\n')

    # Check if any instances reached maximum retries
    if metadata and metadata.eval_output_dir:
        check_maximum_retries_exceeded(metadata.eval_output_dir)


def reset_logger_for_multiprocessing(
    logger: logging.Logger, instance_id: str, log_dir: str
):
    """Reset the logger for multiprocessing.

    Save logs to a separate file for each process, instead of trying to write to the
    same file/console from multiple processes.
    """
    # Set up logger
    log_file = os.path.join(
        log_dir,
        f'instance_{instance_id}.log',
    )
    # Remove all existing handlers from logger
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # add console handler to print ONE line
    console_handler = get_console_handler(log_level=logging.INFO)
    console_handler.setFormatter(
        logging.Formatter(
            f'Instance {instance_id} - ' + '%(asctime)s - %(levelname)s - %(message)s'
        )
    )
    logger.addHandler(console_handler)
    logger.info(
        f'Starting evaluation for instance {instance_id}.\n'
        f'Hint: run "tail -f {log_file}" to see live logs in a separate shell'
    )
    # Only log WARNING or higher to console
    console_handler.setLevel(logging.WARNING)

    # Log INFO and above to file
    os.makedirs(os.path.dirname(log_file), exist_ok=True)
    file_handler = logging.FileHandler(log_file)
    file_handler.setFormatter(
        logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    )
    file_handler.setLevel(logging.INFO)
    logger.addHandler(file_handler)


def update_llm_config_for_completions_logging(
    llm_config: LLMConfig,
    eval_output_dir: str,
    instance_id: str,
) -> LLMConfig:
    """Update the LLM config for logging completions."""
    if llm_config.log_completions:
        llm_config.log_completions_folder = os.path.join(
            eval_output_dir, 'llm_completions', instance_id
        )
        logger.info(
            f'Logging LLM completions for instance {instance_id} to '
            f'{llm_config.log_completions_folder}'
        )
    return llm_config


# events is now available as a filtered stream of events, rather than list of pairs of (Action, Observation)
# we rebuild the pairs here
# for compatibility with the existing output format in evaluations
# remove this when it's no longer necessary
def compatibility_for_eval_events_pairs(
    events: list[Event],
) -> list[tuple[dict, dict]]:
    events_pairs = []

    for action, observation in get_pairs_from_events(events):
        events_pairs.append((event_to_dict(action), event_to_dict(observation)))

    return events_pairs


def is_fatal_evaluation_error(error: str | None) -> bool:
    """
    The AgentController class overrides last error for certain exceptions
    We want to ensure those exeption do not overlap with fatal exceptions defined here
    This is because we do a comparisino against the stringified error
    """
    if not error:
        return False

    fatal_names = [
        'AgentRuntimeError',
        'AgentRuntimeBuildError',
        'AgentRuntimeTimeoutError',
        'AgentRuntimeUnavailableError',
        'AgentRuntimeNotReadyError',
        'AgentRuntimeDisconnectedError',
        'AgentRuntimeNotFoundError',
        'ConnectionError',
    ]

    if any(name in error for name in fatal_names):
        logger.error(f'Fatal evaluation error detected: {error}')
        return True

    return False


def is_fatal_runtime_error(error: str | None) -> bool:
    if not error:
        return False

    fatal_runtime_names = [
        'AgentRuntimeTimeoutError',
        'AgentRuntimeUnavailableError',
        'AgentRuntimeDisconnectedError',
        'AgentRuntimeNotFoundError',
    ]

    if any(name in error for name in fatal_runtime_names):
        logger.error(f'Fatal runtime error detected: {error}')
        return True

    return False


def get_metrics(state: State) -> dict[str, Any]:
    """Extract metrics from the state."""
    metrics = state.metrics.get() if state.metrics else {}
    #Commented for migration
    #metrics['condenser'] = get_condensation_metadata(state)
    return metrics


def get_default_sandbox_config_for_eval() -> SandboxConfig:
    # Store current user info for permission fixes
    current_uid = os.getuid() if hasattr(os, 'getuid') else 1000
    current_gid = os.getgid() if hasattr(os, 'getgid') else 1000

    return SandboxConfig(
        use_host_network=False,
        # large enough timeout, since some testcases take very long to run
        timeout=300,
        api_key=os.environ.get('ALLHANDS_API_KEY', None),
        runtime_startup_env_vars={
            'NO_CHANGE_TIMEOUT_SECONDS': '30',
            'HOST_UID': str(current_uid),
            'HOST_GID': str(current_gid),
        },
        remote_runtime_api_url=os.environ.get('SANDBOX_REMOTE_RUNTIME_API_URL'),
        keep_runtime_alive=False,
        remote_runtime_init_timeout=3600,
        remote_runtime_api_timeout=120,
        remote_runtime_enable_retries=True,
        remote_runtime_class='sysbox',
    )


def filter_dataset(
    dataset: pd.DataFrame, filter_column: str, run_infer_path
) -> pd.DataFrame:
    file_path = os.path.join(run_infer_path, 'config.toml')
    if os.path.exists(file_path):
        with open(file_path, 'r') as file:
            data = toml.load(file)
            if 'selected_ids' in data:
                selected_ids = data['selected_ids']
                logger.info(
                    f'Filtering {len(selected_ids)} tasks from "selected_ids"...'
                )
                subset = dataset[dataset[filter_column].isin(selected_ids)]
                logger.info(f'Retained {subset.shape[0]} tasks after filtering')
                return subset
    skip_ids = os.environ.get('SKIP_IDS', '').split(',')
    if len(skip_ids) > 0:
        logger.info(f'Filtering {len(skip_ids)} tasks from "SKIP_IDS"...')
        return dataset[~dataset[filter_column].isin(skip_ids)]
    return dataset


# Missing classes and functions for migration compatibility
class NoOpCondenserConfig:
    """No-op condenser config for compatibility."""
    def __init__(self):
        pass


def get_condenser_config_arg(name: str):
    """Get condenser config by name - stub implementation."""
    if name == 'NoOpCondenser':
        return NoOpCondenserConfig()
    return None


class CriticResult:
    """Result from agent critic evaluation."""
    def __init__(self, success: bool, message: str = ""):
        self.success = success
        self.message = message


class AgentFinishedCritic:
    """Critic to evaluate if agent finished successfully."""
    
    def evaluate(self, history: list, git_patch: str = "") -> CriticResult:
        """Evaluate if the agent finished successfully based on history and git patch."""
        # Simple heuristic: if there's a git patch, consider it successful
        if git_patch and git_patch.strip():
            return CriticResult(success=True, message="Git patch found")
        
        # Check if the last few events indicate completion
        if history:
            # Look for completion indicators in the last few events
            for event in history[-3:]:
                if isinstance(event, dict):
                    content = str(event.get('content', ''))
                    if any(phrase in content.lower() for phrase in [
                        'task completed', 'finished', 'done', 'completed successfully'
                    ]):
                        return CriticResult(success=True, message="Completion indicator found")
        
        return CriticResult(success=False, message="No clear completion indicator")
